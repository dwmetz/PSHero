#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: a8a01888-d823-441d-8ad2-73ba56602ff8
# Source File: ParseEmailHeader\ParseEmailHeader.pfproj
#------------------------------------------------------------------------
#region Project Recovery Data (DO NOT MODIFY)
<#RecoveryData:
BAUAAB+LCAAAAAAABACNlE1v2zAMhu8D9h8M3x0nadf54BhYnbbLoVuQBLsWrE216mRJkORt/veT
a9nxV4bdzIfkK5qkFB8wE79QVVswkHz84HnxXok3zMy7Yc0fqDQVPFktlnHYGs53TxnutglEsFxF
URTk0foquL5e5UEE+Tr4fPUMn25ulmtCojh0wS7VnXKqJCZWuG/2xLUznOkdkKBCnuE3KHDj+95t
SVm+8Zd+cjSgTCkXkujmrH+npsBY8AiU3wtVPElC+lott2Lkv8UemHgG9iT1qiflpaIogOd3fwzy
unUb/6RK9JMmWi9s+OCExmj+u2uLGwxkP+EFVRv5gBwVsHNpLqCu6QzDWergLuuG2Qsd0kfglKA2
qUIw75sQhxPWRaelNqJo/T3tS449A0Nsr5PA6nZG5z6U/Hj6Uq+I+zonit+ojq/IWLuVayswgW1b
h92Kj5iViprKC8eLPpj0BIaz1M4pLzMzjb7kcHw8qjm6RZ0pKodtDmepXTYJvOp3fUxSIStFX14H
o5myHTeoOLBRgfP4u02mltatGSVcdtUXA/mwjD4ZPjbdbjbbPz1yD0rjXQGUfUXIUdmrK+3lma3A
7lL/1fsL9y7cSgQFAAA=#>
#endregion
#========================================================================
# Code Generated By: SAPIEN Technologies, Inc., PowerShell Studio 2012 v3.1.17
# Generated On: 08/02/2014 13:09
# Generated By: PFLAHE01
#========================================================================


#region Source: Startup.pfs
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
kggAAB+LCAAAAAAABADFVs2O2jAQvlfqO+QBaJw0BJYqREKhVKuWLdqgdg9cjJmwFo6NbAcUaR++
hoaQQNAitBLKJfPN3+exPePgGYjYgMyHWOPw8yfLCn5LuqQcsxFl8IRTCGONpc7W9jpRATrT7n12
0h+QigoeuvbXAFWBvcVAKUjnjILay0ckD+NcaUjtMeZ4CSlwbQ8yLVKsjXPLKqL0XdvZfS0rypjO
JPQ5ZFpi1rImmYlLfkI+FSvgfc+dJ96D38ELr9MGzw9Qmak58zFH+9oc824X+8TvuD2vDc5D7y36
NvtL+UJs1WxMiRRKJNp++j6djaQp0lbI1Wyzi+45ntubFSteMPYuObsIa4+ETNXdqNZYXEd8KPGW
8uUtlB0v8ZNu4roL38Eevo1ykf8dsqkiQjI6/4DKXlESc8nutoW75Nft3EvK7sbyZfzryuNFJRAt
ZB6D3FACN92Njzlop0waFlCKhwYYTDBZmX4nD+v7ARwMx0I8GpRNdg+iRrQAH0nRbWumddR0WZqA
0pGEfYMN3QCdYaV1lCnTiQ/6SuxLignDOjE9Ivxi4pZCqX7OeDwdhE6Air+jo9iCjF+BscPYMFPk
HCyKherVCmIgmaQ6t9ABqTucjKjjOhrRiRSLjOhz60uKAj/dqiZ0CIpIuq6XGTWikUjXmOfVqp8i
kVjnZiC/1rbmHHvkGqQZ2icEm+HGCf/f4bLKMNtN7jrXChKg2msAVU6/OQvVN8g/c3IOH5IIAAA=#>
#endregion
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
[void][Reflection.Assembly]::Load("System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
[void][Reflection.Assembly]::Load("System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")
[void][Reflection.Assembly]::Load("mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
[void][Reflection.Assembly]::Load("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
[void][Reflection.Assembly]::Load("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
[void][Reflection.Assembly]::Load("System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
	Param ([String]$Commandline)
	#Note: This function starts the application
	#Note: $Commandline contains the complete argument string passed to the packager 
	#Note: To get the script directory in the Packager use: Split-Path $hostinvocation.MyCommand.path
	#Note: To get the console output in the Packager (Forms Mode) use: $ConsoleOutput (Type: System.Collections.ArrayList)
	#TODO: Initialize and add Function calls to forms
	
	if((Call-MainForm_pff) -eq "OK")
	{
		
	}
	
	$global:ExitCode = 0 #Set the exit code for the Packager
}







#endregion Source: Startup.pfs

#region Source: MainForm.pff
function Call-MainForm_pff
{
#region File Recovery Data (DO NOT MODIFY)
<#RecoveryData:
jxIAAB+LCAAAAAAABADNWG1v4jgQ/r7S/YconzkgDQG6gkht2u5WV3bRwr58QFqZZGh9dWzkOC05
3Y+/yRsQEkqK6O4JCch4xvPMzOOx48EXcMUTyOiKKGL/8U7TBp8lvaecsBvK4BPxwR4Rym+E9JvL
xWLQKg0nRvHTN5ABFdw2mmeD1rYgnXb+N7hKU9EShvokChT4ze+Ue+I5aMazp98NrWqooWVTDTvN
dvxpaE7IVChhyCFUkrCGNg7njLp/QTQVj8CH816PWK7VNc7NDrT757rGEexQz4PRNfeBMk+iqu4I
rqRggZ4gRaxjKZYgVZTZOIwCVxP6D+h2t201NKuLEeZKe4zi3Ojr3B1Unygi1VgEVGGYuu2gQ5AT
VwLwg7ZTWCndHhMZgHbtE8q0EQQBuQftIxAPM1ee4foJHWTmd4J4uv2Zx78x1mRs0Ep+cv3D1bsM
lRL8zes3T9xcr6h6qYLlHN0Jl6SptYw+VvCsV0rKvhpuXNYwSVnSQ5KcmTXUp2R+yz1Y6XYt7aTQ
NZF8DeAbDULCJipicEncR0cwIXV7KkOost/mBFLefdwO/Wci2WFFK6XF/5QkyYI4liUds3cMSxKf
b0mTcuN5sR/8Up4kHk9DlDiES7F6c6Yo9DMXq6xfpu3yWMoYZkPrtGtkfIRgKaMc9ue4kmJVYOtw
zcUI2CUWR7cxcYq6hNWmqNXH7Hb6xqtIWtZ+PQPuyBzYm9efxV7GBH0Usvrx6L4Rk8Cos6TTku71
X7tAxvnrm0gdkuZNBKHtHCe0B5Dw/uUSFx8uggB8rAcEuW4mieysviPC0YGPLaN5ESrhJ9nc1Nmo
W2fTmC/MvtUlntntgGkNWmtP1Z5PwKV/nfezjJ+zEcXFFoiFan66ns5uJKbyWcjH2VM8u9k2jfNZ
FrHH2EFwJ6f9cVCLC7MW8CtJnim/PwZy21xYi97CMDyrTUxyHOTM/wGwfuAKyej8BJmtkRJ8w/pt
JYyd16vcD5/9NpQ/Rnc16UUlNhchownIJ+rCUWvjNETbRVIRwPoxb4CDMZ6ysN/JPL4PwAExbjXj
VGH9gp022EppJrx1szftgmpRil2WLiBQjoSkwcYbdUm21nbCADtxPr41976BMSNqgT3C/jM+AOQP
6+EvIZ9ML+LNJ/u3MRTP+LL7AIzlVwbxMbckzPeZYrYGE3BDSXHjauWSosHO9cQmjkop7mpe6Kqy
9r6BTL5bqirpFQSupMtimluVUkf4S8Kj7azvShyxjCS9fyiUpiy7jW8SOGE7AKvFlbc72e6+dwiR
+ZvDfobV3z7+F26CWlvsRy5sX0D9B5moKQmPEgAA#>
#endregion
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
	[void][reflection.assembly]::Load("System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
	[void][reflection.assembly]::Load("System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")
	[void][reflection.assembly]::Load("mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
	[void][reflection.assembly]::Load("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
	[void][reflection.assembly]::Load("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")
	[void][reflection.assembly]::Load("System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$MainForm = New-Object 'System.Windows.Forms.Form'
	$buttonExit = New-Object 'System.Windows.Forms.Button'
	$buttonParse = New-Object 'System.Windows.Forms.Button'
	$textboxMessageHeader = New-Object 'System.Windows.Forms.TextBox'
	$labelPasteMessageHeaderHe = New-Object 'System.Windows.Forms.Label'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	$OnLoadFormEvent={
	#TODO: Initialize Form Controls here
	
	}
	
	
	
	
	
	$buttonParse_Click={
	  $AppName = "Parse-EmailHeader.ps1"
	  $AppVer  = "v1.1 11 February 2014"
	
	$htmlHeader = " 
<Style> 
  TABLE{border-width: 1px;padding: 1px;border-style: solid;border-color: black;border-collapse: collapse;} 
  TD{border-width: 1px;padding: 1px;border-style: solid;border-color: black;} 
  TH{font-family:'Arial';font-size:12px;border-width: 1px;padding: 1px;border-style: solid;border-color: black;background-color:silver;} 
  TR{font-family:'Arial';font-size:10px} 
  P{font-family:'Arial';} 
</Style>" 
	
	  $today = Get-Date 
	  $z="<B><FONT size='2' face='VERDANA'>" + $AppName + "</B></font> <FONT size='1' face='VERDANA'>" + $AppVer + "</B></FONT><BR><FONT size='1' face='VERDANA'>Last updated: $today</FONT></FONT><HR size=6 color=midnightblue>" 
	
		
	  $text = $textboxMessageHeader.Text.TrimEnd()
	  $fromObject = Process-ReceivedFrom -text $text
	  $byObject = Process-ReceivedBy -text $text
	  $finalArray = Process-FromByObject $fromObject $byObject
		
	  $HTMLout = $pwd.path + "\Parse-EmailHeader.html"
	  $html1 = $finalArray | Select Hop, Delay, From, By, with, Time | ConvertTo-Html  -head $HtmlHeader  -Title "Parse Email Header" -body $z 
		
	  #Write-Output $finalArray | Select Hop, Delay, From, By, with, Time |  Out-GridView
	  $xheaders = $text.split("`n") | where {$_ -like "X-*"}
	  $xHeaderMatrix = @()
		ForEach($tmpHeader in $xheaders){
		  $tmpMatrix = "" | Select Name, Value
		  $tmpX = $tmpHeader.Split(": ")
		  $tmpMatrix.Name = $tmpX[0]
		  $tmpMatrix.Value = $tmpX[-1]
		  $xHeaderMatrix+= $tmpMatrix
		  
		}
	  $html2 = $xHeaderMatrix  | ConvertTo-Html -Fragment
		
	  $html3  =  "<table><tr><td>" 
	  $html3 += $text.replace("`n","<br>")
	  $html3 +=  "</td></tr></table>" 
		
	  $IPRoute = $finalArray | Select  From, FromIP, FromCountry, FromCity, By, ToIP, ToCountry, ToCity
	
	  $KnownIPFile = $Pwd.path + "\Parse-EmailHeader_KnownIPs.csv"
	  Write-Host "Looking for $KnownIPFile"
	  $KnownIPs  = @{"-" = "-|-"}
	  If(Test-Path $KnownIPFile){
		Write-Host " - Found"
	    $tmpCSV = Import-Csv $KnownIPFile | Sort IP
		$KnownIPs = @{}	
		ForEach($Item in $tmpCSV){$id = $Item.Country + "|" + $Item.City;$KnownIPs.add($item.IP, $id)}
		Write-Host " -- "$KnownIPs.count " Found"
	  }
	  	
	  $ipregex     = "^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	  $BaseUrl = "http://api.hostip.info/get_html.php?ip="
	  Write-Host "Discovering IP Geo Information"
	  ForEach($tmpRoute in $IPRoute){
		Write-Host $tmpFrom + "/" + $tmpTo
	    $tmpFrom = $tmpRoute.FromIP
		$tmpTo   = $tmpRoute.ToIP
		
		if($tmpFrom -match $ipregex){	 
		  $tmpKnown = $KnownIPs.$tmpFrom
		  IF([string]::IsNullOrEmpty($tmpKnown)){
		    $tmpURL = $BaseUrl + $tmpFrom
	  	    $wc = new-object system.net.WebClient
	  	    $webpage = $wc.DownloadData($tmpURL)
	  	    $tmpstring = [System.Text.Encoding]::ASCII.GetString($webpage)
		    $arrString = $tmpstring.Split("`n")
	        $tmpRoute.FromCountry = $arrString[0].Replace("Country: ","")
	        $tmpRoute.FromCity = $arrString[1].Replace("City: ","")
		  }ELSE{
			$tmpKnownA = $tmpKnown.Split("|")
		    $tmpRoute.FromCountry = $tmpKnownA[0]
			$tmpRoute.FromCity    = $tmpKnownA[-1]
		  }
		}		
	    if($tmpTo -match $ipregex){
		  $tmpKnown = $KnownIPs.$tmpTo
		  IF([string]::IsNullOrEmpty($tmpKnown)){
		    $tmpURL = $BaseUrl + $tmpTo
	  	    $wc = new-object system.net.WebClient
	  	    $webpage = $wc.DownloadData($tmpURL)
	  	    $tmpstring = [System.Text.Encoding]::ASCII.GetString($webpage)
		    $arrString = $tmpstring.Split("`n")
	        $tmpRoute.ToCountry = $arrString[0].Replace("Country: ","")
	        $tmpRoute.ToCity = $arrString[1].Replace("City: ","")
	      }ELSE{
			$tmpKnownA = $tmpKnown.Split("|")
		    $tmpRoute.ToCountry = $tmpKnownA[0]
			$tmpRoute.ToCity    = $tmpKnownA[-1]
		  }
		}		
	  }
	
		
	  $Hops = @()
	  #Look at IP Route
	  ForEach($Hop in $IPRoute){
	    If($Hop.FromCountry -notlike "*(XX)*"){
		  if(-not [string]::IsNullOrEmpty($Hop.FromCountry)){
		    $tmpHop = ($Hop.FromCountry.Split("(")[-1].Replace(")",""))
			}ELSE{$tmpHop = "unknown"}
		  $Hops += $tmpHop
		}
		If($Hop.ToCountry -notlike "*(XX)*"){
		  if(-not [string]::IsNullOrEmpty($Hop.ToCountry)){
		    $tmpHop = ($Hop.ToCountry.Split("(")[-1].Replace(")",""))
		  }ELSE{$tmpHop = "unknown"}
		  $Hops += $tmpHop
		}
	  }
	  
	  $MapURL = "http://maps.googleapis.com/maps/api/staticmap?size=800x800&sensor=false&path=color:0xff0000ff|weight:5|"
	  $Line = "UB40SL|E149YY"
	  $Markers = "UB40SL%7CE149YY"	
	  $MapURL += $Line
	  $MapURL += "&markers=size:mid%7Ccolor:red%7C" + $Markers
	
	Write-Host $Hops
		
	  Write-Host $MapURL
		
	  $html4 = $IPRoute | ConvertTo-Html -Fragment
	  $html  = $html1 
	  $html += "<hr size=6 color=midnightblue><FONT size='2' face='VERDANA'><B>X-Headers</B></Font>"         + $html2 
	  $html += "<hr size=6 color=midnightblue><FONT size='2' face='VERDANA'><B>Original Headers</B></Font>"  + $html3
	  $html += "<hr size=6 color=midnightblue><FONT size='2' face='VERDANA'><B>Mail Routing</B></Font>"      +  $html4
		
	  $html | Out-File $HTMLout
	  Invoke-Expression $htmlOut
	  #$MainForm.Close
	  #Exit	
		
	}
	
	
	Function Process-ReceivedBy {Param($text)
	  $regexBy1 = 'Received: by '
	  $regexBy2 = 'Received: by ([\s\S]*?)with([\s\S]*?);([(\s\S)*]{32,36})(?:\s\S*?)'
	  $regexBy3 = 'Received: by ([\s\S]*?);([(\s\S)*]{32,36})(?:\s\S*?)'
	  $byMatches = $text | Select-String -Pattern $regexBy1 -AllMatches
	
	  if ($byMatches) {
	    $byMatches = $text | Select-String -Pattern $regexBy2 -AllMatches
	    if($byMatches) {
	      $rbArray = @()
		  $byMatches.Matches | foreach{
	        $by   = Clean-string $_.groups[1].value
	        $with = Clean-string $_.groups[2].value
			Switch -wildcard ($with) {
	          "SMTP*"  {$with = "SMTP"}
	          "ESMTP*" {$with = "ESMTP"}
	          default{}
	        } #Switch
			$time = Clean-string $_.groups[3].value
			$byhash = @{
				ReceivedByBy = $by
				ReceivedByWith = $with
				ReceivedByTime = [Datetime]$time
			}		
			$byArray = New-Object -TypeName PSObject -Property $byhash		
			$rbArray += $byArray		
			}
			$rbArray
		} else 	{
			$rbArray = @()
			$byMatches = $text | Select-String -Pattern $regexBy3 -AllMatches
			$byMatches.Matches | foreach{
			$by = Clean-string $_.groups[1].value
			$with = ""
			$time = Clean-string $_.groups[2].value
			$byhash = @{
				ReceivedByBy = $by
				ReceivedByWith = $with
				ReceivedByTime = [Datetime]$time
			}
			$byArray = New-Object -TypeName PSObject -Property $byhash		
			$rbArray += $byArray		
			}
			$rbArray
		}
	} else {
		return $null
	}
	}
	
	
	Function Process-ReceivedFrom {
	Param($text)
		$regexFrom1 = 'Received: from([\s\S]*?)by([\s\S]*?)with([\s\S]*?);([(\s\S)*]{32,36})(?:\s\S*?)'
	$fromMatches = $text | Select-String -Pattern $regexFrom1 -AllMatches
	if ($fromMatches)
	{
			
			$rfArray = @()
			$fromMatches.Matches | foreach{
			$from = Clean-string $_.groups[1].value
			$by = Clean-string $_.groups[2].value
			$with = Clean-string $_.groups[3].value
				Switch -wildcard ($with)
				{
				 "SMTP*" {$with = "SMTP"}
				 "ESMTP*" {$with = "ESMTP"}
				 default{}
				}
			$time = Clean-string $_.groups[4].value
			$fromhash = @{
				ReceivedFromFrom = $from
				ReceivedFromBy = $by
				ReceivedFromWith = $with
				ReceivedFromTime = [Datetime]$time
			}		
			$fromArray = New-Object -TypeName PSObject -Property $fromhash		
			$rfArray += $fromArray		
			}
			$rfArray
	}
	else
	{
		return $null
	}
	}
	
	Function Clean-String
	{
	Param([string]$inputString)  
	 $inputString = $inputString.Trim()
	 $inputString = $inputString.Replace("`r`n","")  
	 $inputString = $inputString.Replace("`t"," ") 
	 $inputString
	}
	
	Function Process-FromByObject
	{
	Param([PSObject[]]$fromObjects,[PSObject[]]$byObjects)
		[int]$hop=0
	$delay=""
	$receivedfrom=$receivedby=$receivedtime=$receivedwith=$null
	$prevTime=$null
	$time=$null
	$finalArray = @()
		if($byObjects)
		{		
		 $byObjects = $byObjects[($byObjects.Length-1)..0] # Reversing the Array
		 for($index = 0;$index -lt $byobjects.Count;$index++)
			{
				if($index -eq 0)
				{
					$hop=1
					$delay="*"
					$receivedfrom = ""
					$receivedby = $byobjects[$index].ReceivedByBy
					$with = $byobjects[$index].ReceivedByWith
					$time = $byobjects[$index].ReceivedBytime
					$time = $time.touniversaltime()
					$prevTime = $time
					$finalHash = @{
						Hop   = $hop
						Delay = $delay
						From  = $receivedfrom
						By 	  = $receivedby
						With  = $with
						Time  = $time
						FromIP = $receivedfrom.Split("(")[-1].replace(")","")
						ToIP   = $receivedby.Split("(")[-1].replace(")","")
						}				
					$obj = New-Object -TypeName PSObject -Property $finalHash
					$finalArray += $obj				
				}
				else
				{
					$hop = $index+1				
					$receivedfrom = ""
					$receivedby = $byobjects[$index].ReceivedByBy
					$with = $byobjects[$index].ReceivedByWith
					$time = $byobjects[$index].ReceivedBytime
					$time = $time.touniversaltime()				
					$delay = $time - $prevTime
					$delay = $delay.totalseconds
					if ($delay -le -1) {$delay = 0}				
					$prevTime = $time
									$finalHash = @{
						Hop   = $hop
						Delay = $delay
						From  = $receivedfrom
						By 	  = $receivedby
						With  = $with
						Time  = $time
						FromIP = $receivedfrom.Split("(")[-1].replace(")","")
						ToIP   = $receivedby.Split("(")[-1].replace(")","")
						}				
					$obj = New-Object -TypeName PSObject -Property $finalHash
					$finalArray += $obj
				}
			}
		 $lastHop = $hop
		 
		}
		$hop = $lastHop
		if($fromObjects)
		{		
		 $fromObjects = $fromObjects[($fromObjects.Length-1)..0] #Reversing the Array
		 for($index = 0;$index -lt $fromobjects.Count;$index++)
			{			
			
					$hop = $hop + 1
					$receivedfrom = $fromobjects[$index].ReceivedFromFrom
					$receivedby = $fromobjects[$index].ReceivedFromBy
					$with = $fromobjects[$index].ReceivedFromWith
					$time = $fromobjects[$index].ReceivedFromTime
					$time = $time.touniversaltime()				
					if($prevTime)
					{
						$delay = $time - $prevTime
						$delay = $delay.totalseconds
					}
					else
					{
						$delay = "*"
					}				
					$prevTime = $time
					$finalHash = @{
						Hop   = $hop
						Delay = $delay
						From  = $receivedfrom
						By 	  = $receivedby
						With  = $with
						Time  = $time
						FromIP = $receivedfrom.Split("(")[-1].replace(")","")
						ToIP   = $receivedby.Split("(")[-1].replace(")","")
						}				
					$obj = New-Object -TypeName PSObject -Property $finalHash
					$finalArray += $obj
				
			}
		 
		}
	$finalArray
	}
	
	
	
	
	$buttonExit_Click={
	  $MainForm.Close()	
		
		
	}
	
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$MainForm.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:MainForm_textboxMessageHeader = $textboxMessageHeader.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$buttonExit.remove_Click($buttonExit_Click)
			$buttonParse.remove_Click($buttonParse_Click)
			$MainForm.remove_Load($OnLoadFormEvent)
			$MainForm.remove_Load($Form_StateCorrection_Load)
			$MainForm.remove_Closing($Form_StoreValues_Closing)
			$MainForm.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch [Exception]
		{ }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	#
	# MainForm
	#
	$MainForm.Controls.Add($buttonExit)
	$MainForm.Controls.Add($buttonParse)
	$MainForm.Controls.Add($textboxMessageHeader)
	$MainForm.Controls.Add($labelPasteMessageHeaderHe)
	$MainForm.ClientSize = '605, 562'
	$MainForm.Name = "MainForm"
	$MainForm.StartPosition = 'CenterScreen'
	$MainForm.Text = "Parse Email Message Headers"
	$MainForm.add_Load($OnLoadFormEvent)
	#
	# buttonExit
	#
	$buttonExit.Location = '518, 527'
	$buttonExit.Name = "buttonExit"
	$buttonExit.Size = '75, 23'
	$buttonExit.TabIndex = 3
	$buttonExit.Text = "Exit"
	$buttonExit.UseVisualStyleBackColor = $True
	$buttonExit.add_Click($buttonExit_Click)
	#
	# buttonParse
	#
	$buttonParse.Location = '437, 527'
	$buttonParse.Name = "buttonParse"
	$buttonParse.Size = '75, 23'
	$buttonParse.TabIndex = 2
	$buttonParse.Text = "Parse"
	$buttonParse.UseVisualStyleBackColor = $True
	$buttonParse.add_Click($buttonParse_Click)
	#
	# textboxMessageHeader
	#
	$textboxMessageHeader.Location = '13, 40'
	$textboxMessageHeader.Multiline = $True
	$textboxMessageHeader.Name = "textboxMessageHeader"
	$textboxMessageHeader.ScrollBars = 'Vertical'
	$textboxMessageHeader.Size = '580, 481'
	$textboxMessageHeader.TabIndex = 1
	#
	# labelPasteMessageHeaderHe
	#
	$labelPasteMessageHeaderHe.Location = '13, 13'
	$labelPasteMessageHeaderHe.Name = "labelPasteMessageHeaderHe"
	$labelPasteMessageHeaderHe.Size = '195, 23'
	$labelPasteMessageHeaderHe.TabIndex = 0
	$labelPasteMessageHeaderHe.Text = "Paste Message Header here:"
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $MainForm.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$MainForm.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$MainForm.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$MainForm.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $MainForm.ShowDialog()

}
#endregion Source: MainForm.pff

#region Source: Globals.ps1
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{ 
		if($hostinvocation -ne $null)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	
	
	
#endregion Source: Globals.ps1

#Start the application
Main ($CommandLine)
